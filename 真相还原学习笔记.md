# 真相还原学习笔记

- [真相还原学习笔记](#真相还原学习笔记)
  - [前置知识](#前置知识)
    - [软件如何访问硬件](#软件如何访问硬件)
    - [特权级](#特权级)
    - [内存访问为什么要分段](#内存访问为什么要分段)
    - [代码中为啥分为代码段、数据段，这和内存访问机制中的段是一回事吗](#代码中为啥分为代码段数据段这和内存访问机制中的段是一回事吗)
    - [物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别](#物理地址逻辑地址有效地址线性地址虚拟地址的区别)
    - [什么是段重叠](#什么是段重叠)
    - [平坦模型](#平坦模型)
    - [寄存器](#寄存器)
    - [工程和协议](#工程和协议)
    - [局部变量和函数参数为什么要放在栈中](#局部变量和函数参数为什么要放在栈中)
    - [Section和Segment的区别](#section和segment的区别)
    - [BIOS、MBR、DBR、OBR](#biosmbrdbrobr)
  - [计算机启动过程](#计算机启动过程)
    - [CPU的实模式](#cpu的实模式)
      - [CPU工作原理](#cpu工作原理)
      - [CPU的寄存器](#cpu的寄存器)
    - [实模式下CPU寻址](#实模式下cpu寻址)
      - [寄存器寻址](#寄存器寻址)
      - [立即数寻址](#立即数寻址)
      - [内存寻址](#内存寻址)
        - [直接寻址](#直接寻址)
        - [基址寻址](#基址寻址)
        - [変址寻址](#変址寻址)
        - [変址基址寻址](#変址基址寻址)
    - [实模式下的ret](#实模式下的ret)
    - [实模式下的call](#实模式下的call)
      - [16位实模式相对近调用](#16位实模式相对近调用)
      - [16位实模式间接绝对近调用](#16位实模式间接绝对近调用)
      - [16位实模式直接绝对远调用](#16位实模式直接绝对远调用)
      - [16位实模式间接绝对远调用](#16位实模式间接绝对远调用)
    - [实模式下的jmp](#实模式下的jmp)


## 前置知识

### 软件如何访问硬件

硬件更新非常迅速，操作系统为了适应各种不断迭代更新的硬件，出现了各种硬件适配器（`IO`接口）

硬件在输入输出上大体分为串行和并行,相应的接口也就是串行接口和并行接口。串行硬件通过串行
接口与 `CPU` 通信,反过来也是,`CPU` 通过串行接口与串行设备数据传输。并行设备的访问类似,只不过
是通过并行接口进行的。

访问外部硬件有两个方式。

1. 将某个外设的内存映射到一定范围的地址空间中,`CPU` 通过地址总线访问该内存区域时会落到外设的内存中,这种映射让 `CPU` 访问外设的内存就如同访问主板上的物理内存一样。
2. 外设是通过 `IO` 接口与 `CPU` 通信的,`CPU` 访问外设,就是访问 `IO` 接口,由 `IO` 接口将信息传递给另一端的外设,也就是说,`CPU` 从来不知道有这些设备的存在,它只知道自己操作的 `IO` 接口。

> 如何访问到 `IO` 接口呢
>
> 答案就是 `IO` 接口上面有一些寄存器,访问 `IO` 接口本质上就是访问这些寄存器,这些寄存器就是人们常说的端口。这些端口是人家 `IO` 接口给咱们提供的接口。

------


### 特权级

应用程序处于特权级 3,操作系统内核处于特权级 0。

------


### 内存访问为什么要分段

分段是给`CPU`用的访问内存的方式。

程序分段首先是为了重定位，其次又是为了将大内存分成可以访问的小段。

> 1M 是 2 的 20 次方,1MB 内存需要 20 位的地址才能访问到,如何做到用 16 位寄存器访问 20 位地址空间呢?
>
> 这是因为 CPU 设计者在地址处理单元中动了手脚,该地址部件接到“段基址+段内偏移地址”的地址后,自动将段基址乘以 16,即左移了 4 位,然后再和 16 位的段内偏移地址相加,这下地址变成了 20 位了

------


### 代码中为啥分为代码段、数据段，这和内存访问机制中的段是一回事吗

**程序不是一定要分段才能运行的,分段只是为了使程序更加优美。**

只要给出 `CPU` 第一个指令的起始地址,`CPU` 在它执行本指令的同时,它会自动获取下一条的地址,然后重复上述过程,继续执行,继续取址。这就要求程序中的指令都是挨着的，彼此之间无空隙。

> 程序中不是有对齐这回事吗?为了对齐,编译器在程序中塞了好多 0。是的,对齐确实是让程序中出现了好多空隙,但这些空隙是数据间的空隙,指令间不存在空隙,下一条指令的地址是按照前面指令的尺寸大小排下来的。即使指令间有空隙或其他非指令的数据,这也仅仅是在物理上将其断开了,依然可以用 `jmp`指令将非指令部分跳过以保持指令在逻辑上连续

**为了让程序内指令接连不断地执行,要把指令全部排在一起,形成一片连续的指令区域,这就是代码段。把数据连续地并排在一起存储形成的段落，就称为数据段。**

**尽量把同一属性的数据放在一起,这样易于维护。**这样有以下好处：

- 可以为它们赋予不同的属性。数据需要有可写的属性，代码需要有只读的属性。
- 为了提高 `CPU` 内部缓存的命中率。
- 节省内存。程序中存在一些只读的部分,比如代码,当一个程序的多个副本同时运行时(比如同时执行多个 ls命令时),没必要在内存中同时存在多个相同的代码段,这将浪费有限的物理内存资源,只要把这一个代码段共享就可以了。

> 数据段或代码段的属性是谁给添加上的呢,是谁又去根据属性保护程序的呢
>
> 编译器负责挑选出数据具备的属性,从而根据属性将程序片段分类,比如,划分出了只读属性的代码段和可写属性的数据段。
>
> 操作系统通过设置 `GDT` 全局描述符表来构建段描述符,在段描述符中指定段的位置、大小及属性(包括 `S` 字段和 `TYPE` 字段)。是真正给段添加属性的地方。
>
> `CPU` 中的段寄存器提前被操作系统赋予相应的选择子,从而确定了指向的段。

总结一下,**程序中的段只是逻辑上的划分,用于不同数据的归类,但是可以用 `CPU` 中的段寄存器直接指向它们**,然后用内存分段机制去程序中分段在平坦模型和访问程序中的段。

内存分段指的是处理器为访问内存而采用的机制,称之为内存分段机制,程序分段是软件中人为逻辑划分的内存区域,它本身也是内存,所以处理器在访问该区域时,也会采用内存分段机制,用段寄存器指向该区域的起始地址。

------


### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

![Alt text](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png)

------


### 什么是段重叠

`CPU` 的内存寻址方式是:给我一个段基址,再给我一个相对于该段起始位置的偏移地址,我就能访问到相应内存。它并不要求一个内存地址只隶属于某一个段,所以在上面的图  中,欲访问内存 `0xC03`,段基址可以选择 `0xC00`, `0xC01`,`0xC02`,`0xC03`,只不过是段内偏移量要根据段基地址来调整罢了。用这种“段基地址:段内偏移”的组合,`0xC00:3` 和`0xC02:1` 是等价的,它们都访问到同一个物理内存块。但段的大小决定于段内偏移地址寻址范围,假设段 A 的段基址是从 0xC00 `开始`,段 B 的段基址是从 `0xC02` 开始,在 16 位宽度的寻址范围内,这两个段都能访问到 `0xC05` 这块内存。用段 A 去访问,其偏移为 5,用段 B 去访问,其偏移量为 3。这样一来,用段 B 和段 A 在地址 0xC02 之后,一直到段 B偏移地址为 `0xfffe` 的部分,像是重叠在一起了,这就是段重叠。

![Alt text](%E6%AE%B5%E9%87%8D%E5%8F%A0.png)

------


### 平坦模型


平坦模型（Flat Model）是一种**内存管理模型**，它将整个物理内存视为单一的、连续的地址空间，不区分段。这与分段模型和分页模型是相对的。

在平坦模型中，**内存地址由一个单一的线性地址空间表示，该空间从零开始，一直延伸到系统支持的最大物理地址。**这种模型简化了内存管理，使得程序员不需要关心段的概念，而是使用连续的线性地址。

------


### 寄存器

`CS`—代码段寄存器(`Code Segment Register`),其值为代码段的段基值。

`DS`—数据段寄存器(`Data Segment Register`),其值为数据段的段基值

`ES`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,称为“附加”是因为此段寄存器用途不像其他 `sreg` 那样固定,可以额外做他用。

`FS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,同上,用途不固定,使用上灵活机动。

`GS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值。

`SS`—堆栈段寄存器(`Stack Segment Register`),其值为堆栈段的段值。

> 32 位 `CPU` 有两种不同的工作模式:实模式和保护模式。
> 每种模式下,段寄存器中值的意义是不同的,但不管其为何值,在段寄存器中所表达的都是指向的段在哪里。
>
> 在实模式下,`CS`、`DS`、`ES`、`SS` 中的值为段基址,是具体的物理地址,内存单元的逻辑地址仍为“段基值:段内偏移量”的形式。在保护模式下,装入段寄存器的不再是段地址,而是“段选择子”(`Selector`),当然,选择子也是数值,其依然为 16 位宽度。

综上所述，在32位CPU中，不管在16为实模式还是32位保护模式下，用的段寄存器都是同一组,`sreg` 都是 16 位宽。

------


### 工程和协议

软件中的工程是指开发一套软件所需要的全部文件,包括配置环境。

协议是一种大家共同遵守的规约,主要用来实现通信、共享、协作;起初是为避免大家各干各的,无法彼此调用对方成果的情况,从而给大家统一一种接口、一组数据调用或者分析的约定。

------


### 局部变量和函数参数为什么要放在栈中

局部变量只是自己在用,放在数据段中纯属浪费空间,没有必要,故将其放在自己的栈中,随时可以清理,真正体现了局部的意义。

函数参数为什么会放到栈区呢?

- 第一也是其局部性导致的,只有这个函数用这个参数,何必将其放在数据段呢。
- 第二,这是因为函数是在程序执行过程中调用的,属于动态的调用,编译时无法预测会何时调用及被调用的次数，其参数和函数的返回地址也要内存来存储,所以也不知道其会需要多少内存。

------


### Section和Segment的区别

section 称为节,是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域,汇编器会将这两个关键字修饰的区域在目标文件中编译成节,也就是说“节”最初诞生于目标文件中。

segment 称为段,是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合,这个集合称为 segment,也就是段,链接器把目标文件链接成可执行文件,因此段最终诞生于可执行文件中。

------


### BIOS、MBR、DBR、OBR

BIOS是计算机接电后运行的第一个程序

MBR会在BIOS干完一些基础工作后从BIOS那接手系统的控制权（BIOS将0盘0道1扇区的MBR加载到物理地址0x7c00）

MBR将系统控制权交给内核加载器OBR

OBR是DBR遗留下来的，DBR 中的内容大概是:(1)跳转指令,使 MBR 跳转到引导代码;(2)厂商信息、DOS 版本信息;(3)BIOS 参数块 BPB,即 BIOS Parameter Block;

EBR是扩展分区中为了兼容 MBR 才提出的概念,主要是兼容 MBR 中的分区表。分区是用分区表来描述的,MBR 中有分区表,扩展分区中的是一个个的逻辑分区,因此扩展分区中也要有分区表,为扩展分区存储分区表的扇区称为 EBR,

------


## 计算机启动过程

![!\[\](/home/zhuheqin/clone/zhuOS/计算机启动过程.png)](%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png)

### CPU的实模式

实模式是指8086CPU的寻址方式、寄存器大小、指令用法等，可以反应CPU在该环境下如何工作。

**“实” 体现在程序中的地址都是真实的物理地址。**

#### CPU工作原理
CPU划为控制单元、运算单元、存储单元。
控制单元去下一条待运行的指令并存入指令译码器。指令译码器将相应的操作数从内存中取回放入自己的存储单元。运算单元开工

#### CPU的寄存器

寄存器是一种物理存储元件，比一般的存储介质要快。

一般分为两类：**对程序员可见的和对程序员不可见的（内部使用的）**，主要说下对程序员可见的寄存器。

**段寄存器**：指定一片内存的起始地址，也叫段基址，在实模式下乘以16,在保护模式下是一个选择子。

![Alt text](段寄存器.png)

**通用寄存器（每个寄存器功能不单一）：**AX、BX、CX、DX、SI、DI、BP、SP

1. ​	**AX寄存器：累加器**，由AH寄存器（AX高8位）和AL寄存器（AX低8位）组成
2. ​	**CX寄存器：计数器**，用作循环次数的控制
3. ​	**BX寄存器：基址寄存器**，用于存储起始地址
4. ​	**DX寄存器：数据寄存器**，通常只用于保存外设控制器的端口号地址
5. ​	**SI寄存器：源変址寄存器**，用于字符串操作中的数据源地址，即被传送的数据在哪里
6. ​	**DI寄存器：目的変址寄存器**，和SI一样，但是是数据的目的地址，即被传送的数据目的地址在哪里
7. ​	**SP寄存器：栈指针寄存器**，段基址为SS,用来指向栈顶
8. ​	**BP寄存器：基址指针**，BP的方式把栈当成普通的数据段来访问

### 实模式下CPU寻址

寻址方式大方向有三种

- 寄存器寻址

- 立即数寻址

- 内存寻址 --直接寻址、基址寻址、变址寻址、基址変址寻址

  

#### 寄存器寻址

最直接的寻址方式就是寄存器寻址,它是指“数”在寄存器中,直接从寄存器中拿数据就行了。例如下面用 `mul` 指令实现 `0x10*0x9。`

```assembly
mov ax,0x10
mov dx,0x9
mul dx
```

同时这也是立即数寻址

#### 立即数寻址

```assembly
mov ax,0x18
mov ds,ax
```

第一条指令中的源操作数 `0x18` 是立即数,目的操作数 `ax` 是寄存器,所以它既是立即数寻址,也是寄存器寻址。第二条指令中,源操作数和目的操作数都是寄存器,所以纯粹是寄存器寻址。

下面也是立即数寻址

```assembly
mov ax,macro_selector
mov ax,label_start
```

第一条指令的源操作数 `macro_selector` 是个宏,第二条指令的源操作数 `label_start`是个标号,这两个在编译阶段会转换为数字,最终可执行文件中的依然是立即数。

#### 内存寻址

##### 直接寻址

直接寻址,就是将直接在操作数中给出的数字作为内存地址,通过中括号的形式告诉 `CPU`,取此地址中的值作为操作数。

```assembly
mov ax,[0x1234]
mov ax,[fs:0x5678]
```

注意，这里`0x1234`是段偏移地址，默认的段地址是`DS`，这条指令是将内存地址 `DS:0x1234` 处的值写入 `ax` 寄存器。段基址*16 变成 20 位地址后,再加上段内偏移地址 `0x1234`。

##### 基址寻址

基址寻址,就是在操作数中用 bx 寄存器或寄存器作为地址的起始,地址的变化以它为基础。**这里说的是只能用`bx`或`bp`作为基址寄存器**

`bx` 寄存器的默认段寄存器是 `DS`,而 `bp` 寄存器的默认段寄存器是 `SS`

> `bp`是用来访问栈的，另外一个用来访问栈的寄存器是`sp`。`sp`寄存器用`push`和`pop`指令来操作栈，但这样只能访问到栈顶。寄存器`bp`可以给出栈中偏移量，所以`bp`默认的段寄存器`SS`,这样就可以通过`SS：bp`的方式把栈当成普通的数据段来访问

```ass
section .data
    ; 数据段，定义一些数据
    base_array db 10, 20, 30, 40, 50

section .text
    global _start

_start:
    ; 设置基址寄存器
    mov esi, base_array

    ; 设置偏移量
    mov ecx, 2  ; 假设要访问数组的第三个元素，偏移量为 2

    ; 计算内存地址，基址 + 偏移量
    add esi, ecx

    ; 在这个例子中，esi 中存储了要访问的内存地址

    ; 可以进行其他操作，比如将该地址的值加载到寄存器中
    mov al, [esi]  ; 将基址 + 偏移量处的值加载到 al 寄存器

    ; 现在，al 中存储了数组第三个元素的值，即 30

    ; 退出程序
    mov eax, 1     ; syscall number for exit
    xor ebx, ebx   ; status: 0
    int 0x80       ; call kernel

```

##### 変址寻址

変址寻址和基址寻址类似，只是寄存器有`bx`、`bp`换成了`si`和`di`。`si`是源索引寄存器，`di`是目的索引寄存器。两个寄存器默认的段寄存器都是`ds`。

```assembly
mov [di],ax  ;将寄存器ax的值存入ds：di指向的内存
mov [si+0x1234],ax    ;変址中也可以加偏移量
```

##### 変址基址寻址

```assembly
mov [bx+di],ax
add [bx+si],ax
```

第一条指令是将 `ax` 中的值送入以 `ds` 为段基址,`bx`+`di` 为偏移地址的内存。第二条指令是将 `ax` 与`[ds:bx+si]`处的值相加后存入内存`[ds:bx+si]`。

### 实模式下的ret

`call` 指令调用一个函数时,压入返回地址,为将来能够回来埋下伏笔。`call` 指令不负责“回来”,它只负责如何“去”,回来的工作要交给 `ret`。

对于 `CPU` 来说,它是靠程序计数器 `PC` 来指路的,所以路就在 `PC` 中。在 `x86` 中的程序计数器是 `CS`:`IP`,具体保留 `IP`部分还是 `CS` 和 `IP` 都保留,是要看目标函数的段基址是否和当前段基址一致,也就是说,是否跨段访问了。

`call` 和 `ret` 是一对配合,用于近调用和近返回,`call` `far` 和 `retf` 是一对配合,用于远调用和远返回。

### 实模式下的call

`call`用于执行完一段分支后再回来的情况（需要有`ret`或者`retf`的配合）。

`call`的调用有四种方式

- 16位实模式相对近调用
- 16位实模式间接绝对近调用
- 16 位实模式直接绝对远调用
- 16 位实模式间接绝对远调用

先解释一下近这个概念。

> 近说明`call`指令所调用的目标函数和当前代码段是同一个段，不用切换段，不用换段基址，只需给出段偏移地址

 

#### 16位实模式相对近调用

名字上和“近”有关的调用就可以用关键字 `near` 来修饰,`near` 表示在内存或寄存器中取 2 字节,这是一种数据类型转换,和数据类型伪指令 `word` 作用相同。`near` 可以省略,`nasm` 编译器默认在地址处取 2 字节。

> 指令格式是 call near 立即数地址

假如 `proc_name` 被编译器分配的地址是 `0x1234`,**`call` 指令最终的操作数并不是 `0x1234`,而是目标地址减去当前 `call` 指令的地址,所得的差再减去此指令的长度 3,最终的结果才是 `call` 相对近调用指令的操作数**

#### 16位实模式间接绝对近调用

**“间接”：目标函数地址没有直接给出，要么在寄存器中，要么在内存中。**

**“绝对”：目标函数地址是绝对地址。**

依然是近调用，只给出段内偏移就好，不用段基址。

#### 16位实模式直接绝对远调用

**“直接”：操作数在指令中直接给出，是立即数，不经过寄存器或内存。**

指令形式如下：

```assembly
call far 段基址（立即数）:段内偏移地址（立即数）
```

```assembly
section call_test vstart=0x900
call 0:far_proc
jmp $
far_proc:
	mov ax,0x1234
	retf
```

#### 16位实模式间接绝对远调用

不支持寄存器寻址，只支持内存寻址。

指令格式：

```assembly
call far 内存寻址
/*call far [bx]
call far [0x1234]
*/
```

```assembly
section call_test vstart=0x900
call far [addr]
jmp $
addr dw far_proc,0
far_proc:
	mov ax,0x1234
	retf
```

### 实模式下的jmp

无条件跳转，改变CPU航线，将程序流转移到新的位置，只要CS:IP寄存器值，不需要保存他们的值。

一共有5类转移方式 ：

- 16位实模式相对短转移：操作数范围为-128～127

  ​	格式：

  ​	

  ```assembly
  jmp short 立即数
  ```

  ​	jmp的操作数CPU不能直接用，是个地址差（目标地址减去jmp所在地址，再减去jmp指令机器码大小2字节）

- 16位实模式相对近转移

- 16位实模式间接绝对近转移

- 16位实模式直接绝对远转移

- 16位实模式间接绝对远转移
