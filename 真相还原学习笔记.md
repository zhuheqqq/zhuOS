# 真相还原学习笔记

## 前置知识

### 软件如何访问硬件

硬件更新非常迅速，操作系统为了适应各种不断迭代更新的硬件，出现了各种硬件适配器（`IO`接口）

硬件在输入输出上大体分为串行和并行,相应的接口也就是串行接口和并行接口。串行硬件通过串行
接口与 `CPU` 通信,反过来也是,`CPU` 通过串行接口与串行设备数据传输。并行设备的访问类似,只不过
是通过并行接口进行的。

访问外部硬件有两个方式。

1. 将某个外设的内存映射到一定范围的地址空间中,`CPU` 通过地址总线访问该内存区域时会落到外设的内存中,这种映射让 `CPU` 访问外设的内存就如同访问主板上的物理内存一样。
2. 外设是通过 `IO` 接口与 `CPU` 通信的,`CPU` 访问外设,就是访问 `IO` 接口,由 `IO` 接口将信息传递给另一端的外设,也就是说,`CPU` 从来不知道有这些设备的存在,它只知道自己操作的 `IO` 接口。

> 如何访问到 `IO` 接口呢
>
> 答案就是 `IO` 接口上面有一些寄存器,访问 `IO` 接口本质上就是访问这些寄存器,这些寄存器就是人们常说的端口。这些端口是人家 `IO` 接口给咱们提供的接口。
 
------


### 特权级

应用程序处于特权级 3,操作系统内核处于特权级 0。

------


### 内存访问为什么要分段

分段是给`CPU`用的访问内存的方式。

程序分段首先是为了重定位，其次又是为了将大内存分成可以访问的小段。

> 1M 是 2 的 20 次方,1MB 内存需要 20 位的地址才能访问到,如何做到用 16 位寄存器访问 20 位地址空间呢?
>
> 这是因为 CPU 设计者在地址处理单元中动了手脚,该地址部件接到“段基址+段内偏移地址”的地址后,自动将段基址乘以 16,即左移了 4 位,然后再和 16 位的段内偏移地址相加,这下地址变成了 20 位了

------


### 代码中为啥分为代码段、数据段，这和内存访问机制中的段是一回事吗

**程序不是一定要分段才能运行的,分段只是为了使程序更加优美。**

只要给出 `CPU` 第一个指令的起始地址,`CPU` 在它执行本指令的同时,它会自动获取下一条的地址,然后重复上述过程,继续执行,继续取址。这就要求程序中的指令都是挨着的，彼此之间无空隙。

> 程序中不是有对齐这回事吗?为了对齐,编译器在程序中塞了好多 0。是的,对齐确实是让程序中出现了好多空隙,但这些空隙是数据间的空隙,指令间不存在空隙,下一条指令的地址是按照前面指令的尺寸大小排下来的。即使指令间有空隙或其他非指令的数据,这也仅仅是在物理上将其断开了,依然可以用 `jmp`指令将非指令部分跳过以保持指令在逻辑上连续

**为了让程序内指令接连不断地执行,要把指令全部排在一起,形成一片连续的指令区域,这就是代码段。把数据连续地并排在一起存储形成的段落，就称为数据段。**

**尽量把同一属性的数据放在一起,这样易于维护。**这样有以下好处：

- 可以为它们赋予不同的属性。数据需要有可写的属性，代码需要有只读的属性。
- 为了提高 `CPU` 内部缓存的命中率。
- 节省内存。程序中存在一些只读的部分,比如代码,当一个程序的多个副本同时运行时(比如同时执行多个 ls命令时),没必要在内存中同时存在多个相同的代码段,这将浪费有限的物理内存资源,只要把这一个代码段共享就可以了。

> 数据段或代码段的属性是谁给添加上的呢,是谁又去根据属性保护程序的呢
>
> 编译器负责挑选出数据具备的属性,从而根据属性将程序片段分类,比如,划分出了只读属性的代码段和可写属性的数据段。
>
> 操作系统通过设置 `GDT` 全局描述符表来构建段描述符,在段描述符中指定段的位置、大小及属性(包括 `S` 字段和 `TYPE` 字段)。是真正给段添加属性的地方。
>
> `CPU` 中的段寄存器提前被操作系统赋予相应的选择子,从而确定了指向的段。

总结一下,**程序中的段只是逻辑上的划分,用于不同数据的归类,但是可以用 `CPU` 中的段寄存器直接指向它们**,然后用内存分段机制去程序中分段在平坦模型和访问程序中的段。

内存分段指的是处理器为访问内存而采用的机制,称之为内存分段机制,程序分段是软件中人为逻辑划分的内存区域,它本身也是内存,所以处理器在访问该区域时,也会采用内存分段机制,用段寄存器指向该区域的起始地址。

------


### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

![Alt text](%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png)

------


### 什么是段重叠

`CPU` 的内存寻址方式是:给我一个段基址,再给我一个相对于该段起始位置的偏移地址,我就能访问到相应内存。它并不要求一个内存地址只隶属于某一个段,所以在上面的图  中,欲访问内存 `0xC03`,段基址可以选择 `0xC00`, `0xC01`,`0xC02`,`0xC03`,只不过是段内偏移量要根据段基地址来调整罢了。用这种“段基地址:段内偏移”的组合,`0xC00:3` 和`0xC02:1` 是等价的,它们都访问到同一个物理内存块。但段的大小决定于段内偏移地址寻址范围,假设段 A 的段基址是从 0xC00 `开始`,段 B 的段基址是从 `0xC02` 开始,在 16 位宽度的寻址范围内,这两个段都能访问到 `0xC05` 这块内存。用段 A 去访问,其偏移为 5,用段 B 去访问,其偏移量为 3。这样一来,用段 B 和段 A 在地址 0xC02 之后,一直到段 B偏移地址为 `0xfffe` 的部分,像是重叠在一起了,这就是段重叠。

![Alt text](%E6%AE%B5%E9%87%8D%E5%8F%A0.png)

------


### 平坦模型


平坦模型（Flat Model）是一种**内存管理模型**，它将整个物理内存视为单一的、连续的地址空间，不区分段。这与分段模型和分页模型是相对的。

在平坦模型中，**内存地址由一个单一的线性地址空间表示，该空间从零开始，一直延伸到系统支持的最大物理地址。**这种模型简化了内存管理，使得程序员不需要关心段的概念，而是使用连续的线性地址。

------


### 寄存器

`CS`—代码段寄存器(`Code Segment Register`),其值为代码段的段基值。

`DS`—数据段寄存器(`Data Segment Register`),其值为数据段的段基值

`ES`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,称为“附加”是因为此段寄存器用途不像其他 `sreg` 那样固定,可以额外做他用。

`FS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值,同上,用途不固定,使用上灵活机动。

`GS`—附加段寄存器(`Extra Segment Register`),其值为附加数据段的段基值。

`SS`—堆栈段寄存器(`Stack Segment Register`),其值为堆栈段的段值。

> 32 位 `CPU` 有两种不同的工作模式:实模式和保护模式。
> 每种模式下,段寄存器中值的意义是不同的,但不管其为何值,在段寄存器中所表达的都是指向的段在哪里。
>
> 在实模式下,`CS`、`DS`、`ES`、`SS` 中的值为段基址,是具体的物理地址,内存单元的逻辑地址仍为“段基值:段内偏移量”的形式。在保护模式下,装入段寄存器的不再是段地址,而是“段选择子”(`Selector`),当然,选择子也是数值,其依然为 16 位宽度。

综上所述，在32位CPU中，不管在16为实模式还是32位保护模式下，用的段寄存器都是同一组,`sreg` 都是 16 位宽。

------


### 工程和协议

软件中的工程是指开发一套软件所需要的全部文件,包括配置环境。

协议是一种大家共同遵守的规约,主要用来实现通信、共享、协作;起初是为避免大家各干各的,无法彼此调用对方成果的情况,从而给大家统一一种接口、一组数据调用或者分析的约定。

------


### 局部变量和函数参数为什么要放在栈中

局部变量只是自己在用,放在数据段中纯属浪费空间,没有必要,故将其放在自己的栈中,随时可以清理,真正体现了局部的意义。

函数参数为什么会放到栈区呢?

- 第一也是其局部性导致的,只有这个函数用这个参数,何必将其放在数据段呢。
- 第二,这是因为函数是在程序执行过程中调用的,属于动态的调用,编译时无法预测会何时调用及被调用的次数，其参数和函数的返回地址也要内存来存储,所以也不知道其会需要多少内存。

------


### Section和Segment的区别

section 称为节,是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域,汇编器会将这两个关键字修饰的区域在目标文件中编译成节,也就是说“节”最初诞生于目标文件中。

segment 称为段,是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合,这个集合称为 segment,也就是段,链接器把目标文件链接成可执行文件,因此段最终诞生于可执行文件中。

------


### BIOS、MBR、DBR、OBR

BIOS是计算机接电后运行的第一个程序

MBR会在BIOS干完一些基础工作后从BIOS那接手系统的控制权（BIOS将0盘0道1扇区的MBR加载到物理地址0x7c00）

MBR将系统控制权交给内核加载器OBR

OBR是DBR遗留下来的，DBR 中的内容大概是:(1)跳转指令,使 MBR 跳转到引导代码;(2)厂商信息、DOS 版本信息;(3)BIOS 参数块 BPB,即 BIOS Parameter Block;

EBR是扩展分区中为了兼容 MBR 才提出的概念,主要是兼容 MBR 中的分区表。分区是用分区表来描述的,MBR 中有分区表,扩展分区中的是一个个的逻辑分区,因此扩展分区中也要有分区表,为扩展分区存储分区表的扇区称为 EBR,

------


## 计算机启动过程

![](/home/zhuheqin/clone/zhuOS/计算机启动过程.png)
